# 가비지 컬렉션의 모든 것


- 자바의 메모리 관리 방법 
- JVM의 Heap 영역에서 동적으로 할당했던 메모리 중 필요없게 된 객체를 모아 주기적으로 제거하는 프로세스
- 개발자 입장에서 메모리 관리, 메모리 누수 문제에 대해 관리 하지 않도 된다


단점

- 자동으로 처리 해준다고 해도 메모리가 언제 해제되는지 정확하게 알 수 없어 제어하기 힘들다
- 가바지 컬렉션이 동작하는 동안에는 다른 동작을 멈추기 때문에 오버헤드가 발생되는 문제점이 있다

오버헤드가 발생되다라는 용어를 Stop-The-World라고 한다

### STW(Stop The World)
---

- GC를 수행하기 위해 JVM이 프로그램 실행을 멈추는 현상
- GC가 작동하는 동안에 GC 관련된 쓰레드를 제외한 모든 쓰레드는 멈추게 되어서 서비스 이용에 차질이 생길 수 있다
- 이 시간을 최소화 시키는 것이 쟁점이다
- 실시간 성이 매우 중요한 프로그램일 경우에는 가바지 컬렉터에게 메모리를 맞기는 것은 맞지 않을 수 있다
- 이렇게 GC 최적화 작업을 GC 튜닝이라고 한다



### 가비지 컬렉션 대상
---

- 가비지 컬렉션은 특정 객체가 garbage인지 아닌지 판단하기 위해서 도달성, 도달 능력 이라는 개념을 적용한다
- 객체에 참조가 있다면 Reachable로 구분
- 객체에 유요한 참조가 없다면 Unreachable로 구분해버리고 수거한다


- JVM 메모리에서는 객체들을 실질적으로 Heap영역에서 생성된다
- Method Area이나 Stack Area에서는 Heap Area에 생성된 객체의 주소만 참조하는 형식으로 구성됨

- Heap Area의 객체들이 메서드가 끝나는 등의 특정 이벤트들로 인하여 Heap Area 객체의 메모리 주소를 가지고 있는 참조 변수가 삭제되는 현상이 발생하면 이 객체는 Heap 영역에서 참조하고 있지 않은 객체(Unreachable)로 구분된다

- 이런 객체들을 주기적으로 가비지 컬렉터가 제거해 준다



### 가비지 컬렉션 청소 방식
---

#### Mark And Sweep

- GC에서 사용되는 개체를 솎아내는 내부 알고리즘
- GC가 동작하는 아주 기초적인 청소 과정
- 루트로 부터 해당 객체에 접근이 가능한지가 해제의 기준이 된다

- 가비지 컬렉션이 될 대상 객체를 식별(Mark)하고 제거(Sweep)하여 객체가 제거되어 흩어져 있던 메모리 영역을 앞에서부터 채워나가는 작업을 수행함

- **Mark 과정** : Root Space로 부터 그래프 순회를 통하여 연결된 객체들을 찾아내어 각각 어떤 객체를 참조하고 있는지 찾아서 마킹

- **Sweep 과정** : 참조하고 있지 않은 객체 즉 Unreachable 객체들을 Heap에서 제거

- **Compact 과정** : Sweep 후에 분산된 객체들을 Heap 의 시작 주소로 모아서 메모리가 할당된 부분과 그렇지 않은 부분으로 압축함



### 가비지 컬렉션 동작 과정
---

#### heap 메모리의 구조

- JVM의 힙 영역은 동적으로 reference 데이터가 저장되는 공간으로 가비지 컬렉션에 대상이 되는 공간

Heap 영역은 처음 설계될 때 다음의 2가지를 전제로 설계됨
-  대부분의 객체는 금방 접근 불가능한 상태 (Unreachable)가 된다
- 오래된 객체에서 새로운 객체로의 참조는 아주 적게 존재

**객체는 대부분 일회성 되며 메모리에 오랫동안 남아 있는 경우는 드물다**

JVM 개발자들은 Heap의 이런 특성을 이용해서 효율적인 메모리 관리를 위해, 객체의 생존 기간에 따라 물리적인 Heap영역을 나누게 되었다

Heap영역에서는 **Young과 Old** 총 2가지의 영역으로 설계하였다

Young -> 새로운 객체들이 할당되는 여역
Old -> Young에서 오랫동안 살아남은 객체들이 존재하는 영역


#### Young 영역
---

- 새롭게 생성된 객체가 할당 되는 영역
- 대부분의 객체가 Unreachable상태가 되기 때문에 많은 객체가 Young 영역에 생성 되었다가 사라진다
- Young 영역에 대한 가비지 컬렉션을 Minor GC라고 부른다


#### Old 영역
---

- Young 영역에서 Reachable 상태를 유지하여 살아남은 객체가 복사되는 영역
- Young 영역보다 크게 할당되며 영역의 크기가 큰 만큼 가비지는 적게 발생함 
- Old 영역에 대한 가비지 컬렉션을 Major GC 또는 Full CG라고 부름


**Old 영역이 Young 영역보다 크게 할당되는 이유**

- Young 영역의 수명이 짧은 객체들은 큰 공간을 필요로 하지 않는다
- 큰 객체들은 Young 영역이 아니라 바로 Old 영역에 할당되기 때문


##### Young 영역에서는 3가지 영역으로 나뉜다
---

- Eden

	- new를 통해 새로 생성된 객체가 위치
	- 정기적인 쓰레기 수집 후 살아남은 객체들은 Survivor 영역으로 보낸다


- Survivor 0 / Survivor 1

	- 최소 1번의 GC 이상 살아남은 객체가 존재하는 영역
	- Survivor 0 또는 Survivor 1 둘 중 하나는 꼭 비어 있어야하는 규칙이 있다


JAVA 8에서의 Permanent

- 생성된 객체들의 정보의 주소값이 저장된 공간
- 클래스 로더에 의해 load되는 Class, Method 등에 대한 Meta 정보가 저장되는 영역
- JVM에 의해 사용됨

자바 7 까지는 힙 영역에 존재했지만 자바 8 버전 이후에는 Native Method Stack 에 편입되게 된다


### Minor GC 과정
---

- 모든 객체는 처음에 Young Generation에 생성되게 됨
- Young 공간은 Old 에 비해 상대적으로 작기 때문에 메모리 상의 객체를 찾아 제거하는데 적은 시간이 걸림
- 작은 공간에서 데이터를 찾아서 그런다

- Young Generation 영역에서 발생되는 GC를 Minor GC라고 불림

1. 처음 생성된 객체는 Young 영역에서의 Eden 영역에 위치

2. Eden 영역이 꽉차게 되면 Minor GC가 실행된다

3. Mark 동작으로 reachable 객체를 탐색한다

4. Eden 영역에서 살아남은 객체는 1개의 Survivor 영역으로 이동

5. Eden 영역에서 Unreachable 메모리를 해체한다 (sweep)

6. 여기에서 살아남은 모든 객체들은 age 값이 1씩증가한다


**age 값이란?**

- Survivor영역에서 객체가 살아남은 횟수를 의미
- Object Header에 기록됨
- age값이 기본임계값 31에 다다르면 Old 영역으로 이동 여부를 결정함
- 객체 헤더에 age를 기록하는 부분이 6 비트로 되어 있다


7. 다시 Eden 영역에 새로운 객체들로 가득 차게 되면 다시한번 minor GC 발생하고 mark 함

8. marking 한 객체들을 비어있는 Survival 1으로 이동하고 sweep

9. 다시 살아남은 모든 객체들은 age가 1씩 증가

이러한 과정을 반복한다



## Major GC(Full GC) 과정
---

- 객체들이 계속 Promotion 되어 Old 영역의 메모리가 부족해지면 발생하게 됨


**Minor GC vs Major GC**

- 대상 : young, old
- 실행 시점 : eden 영역이 꽉 찬 경우, old 영역이 꽉 찬 경우
- 실행 속도 : 빠름, 느림


1. 객체의 age가 임계값에 도달하게 되면 old으로 이동된다  이를 Promotion 이라 부름

2. old 영역의 공간이 부족하게 되면 major GC가 발생


majorGC는 시간이 오래걸린다
그래서 Stop-the-world 문제가 발생한다

Major GC가 일어나면 쓰레드가 멈추고 Mark and Sweep 작업을 해야 해서 CPU에 부하를 주기 때문에 멈추거나 버벅이는 현성이 일어나기 때문이다




## 가비지 컬렉션 알고리즘 종류
---

### 1. Serial GC

- 서버의 CPU 코어가 1개 일때 사용하기 위해 개발된 가장 단순한 GC
- GC를 처리하는 쓰레드가 1개여서 stop-the-world 시간이 가장 길다
- Minor GC 에는 Mark-Sweep 을 사용, 
- Major GC 에는 Mark-Sweep-Compact 를 사용
- 보통 실무에서 사용하는 경우 없음



### 2.  Parallel GC

- 자바 8 의 디폴트 GC
- Serial GC와 기본적인 알고리즘은 같지만 Young 영역의 Minor GC를 멀티 쓰레드로 수행한다 
- Old 영역은 싱글 쓰레드
- Serial GC 에 비해 stop-the-world 시간 감소

- GC 스레드는 기본적으로 cpu 개수만큼 할당
- 옵션을 통하여 GC를 수행할 쓰레드의 갯수 등을 설정 할수 있음


### 3. Parallel Old GC

- Parallel GC를 개선한 버전
- Young 과 Old 영역에서 멀티 쓰레드로 GC 수행
- Mark-Summary-Compact 방식 이용


### 4. CMS GC

- 어플리케이션의 쓰레드와 GC 쓰레드가 동시에 실행되어 stop-the-world 시간을 최대한 줄이기 위해 고안 된 GC
- GC 과정이 복잡함
- 다른 GC 보다 사용량이 높다
- 자바 9 부터는 deprecated되었고 자바 14에서는 사용이 중지


## 5. G1 GC 

- CMS GC를 대처하기 위해 jdk 7버전에서 최초로 release 된 GC
- 자바 9 부터 디폴트 GC로 지정
- 4GB 이상의 힙 메모리, Stop the World 시간이 0.5초 정도 필요한 상황에 사용한다 
- Heap 이 너무 작을 경우에는 미사용 권장
- 기본에는 Heap 영역을 물리적으로 고정된 Young/Old 영역으로 나누어 사용하였지만
- 이러한 개념을 다 빼고 Region 이라는 개념을 새로 도입
- 전체 Heap 영역을 Region이라는 영역으로 체스 같이 분할하여 상황에 따라 Eden, Survivor, Old 등 역할을 고정이 아닌 동적으로 부여한다
- Garbage로 가득찬 영역을 빠르게 회수하여 빈 공간을 확보하므로 결국 GC 빈도가 줄어드는 효과를 얻게 되는 원리



#### **Region**

- 이전에 일일히 메모리를 탐색하여 객체들을 제거하지 않는다
- 메모리가 많이 차있는 영역을 인식하여 우선적으로 GC한다
- Heap Memory 전체를 탐색하는 것이 아니라 영역을 나눠서 탐색하고 영역 별도로 GC가 일어남

- 원래는 Eden -> Survivor0 -> Survivor 1으로 순차적으로 이동 했지만 여기에서는 순차적으로 이동 하지 않음
- 더 효율적이라고 생각하느 위치로 객체를 재할당 한다



### 6. Shenandoah GC

- 자바 12에 release
- 레드 햇에서 개발
- 기존 CMS가 가진 단편화, G1이 가진 pause의 이슈를 해결
- 강력한 Concurrency와 가벼운 GC 로직으로 heap 사이즈에 영향을 받지 않고 일정한 pause 시간이 소요가 특징


### 7. ZGC

- 자바 15에 release
- 대량의 메모리를 low-latency로 잘 처리하기 위해 디자인 된 GC
- G1의 Region 처럼 ZPage라는 영역을 사용함
- G1의 Region은 크기가 고정인데 
- ZPage는 2mb 배수로 동적으로 운영됨
- 장점 : 힙 크기가 증가하더라도 stop-the-world의 시간이 절대 10ms를 넘지 않는다
- 





